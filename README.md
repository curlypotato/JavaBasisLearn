# JavaBasisLearn
java基础学习：基础篇（算法与数据结构）

## 1、二分查找（basis/BinarySearch）
   #### 描述：取中间数找指定数比大小，再取正确的区间的中间值依次对比，返回对应索引。
   #### 编写：
       * a.数组A
       * b.左边界L、右边界R
       * c.中间索引：M = Floor((L + R) / 2)
       * d.中间索引的值：A[M]与搜索数T对比：
            等于 : 返回中间索引
            大于 ：右侧无需对比，向左找:R = M - 1
            小于 ：左侧无需对比，向右找:L = M + 1
       * f.当 L > R时，表示没有找到，结束循环
   
   #### 问题：获取中间索引，整数溢出问题
         使用左移运算： (L + R) >>> 1  
   #### 代码：JDK中Arrays.binarySearch


## 2、排序（basis/Sort）
    冒泡、选择、插入、希尔、快速排序
### 冒泡（Sort.bubble/bubbleImprove）
   #### 图解：
   ![bubble](https://user-images.githubusercontent.com/49053144/202761912-8dd59fb5-f980-4859-b0ad-04d98cff0b64.gif)
   
   #### 描述：
      依次比较数组中两个相邻元素大小，交换两个元素，两两都比较一遍称为一轮冒泡，结果是让最大的元素排至最后，重复以上步骤，直至有序。
      
   #### 优化：
      每轮冒泡时，最后一次交换索引可以作为下一轮冒泡的比较次数，如果这个值为0，表示整个数组有序，直接退出外层循环。
   
### 选择（Sort.selection）
   #### 图解：
   ![selection](https://user-images.githubusercontent.com/49053144/202763722-4c19bfef-bdb2-457b-b7ba-36239d83fe8a.gif)

   #### 描述：
      将数组分为两个子集，排序的和未排序的，每轮从未排序的子集中选出最小的元素，放入排序子集，重复以上步骤，直至有序。
      
   #### 优化：
      减少交换次数，每轮可先找到最小的索引，在每轮最后交换元素。
      
 ***冒泡与选择的比较***
 
      1、二者平均时间复杂度都是O(n^2)【都比较慢的】；
      2、选择排序一般要**快于**冒泡的，交换次数少；
      3、但如果集合**有序**度高，冒泡**优于**选择；
      4、冒泡属于**稳定**排序算法，而选择**不稳定*的。
      
      
### 插入（Sort.insert）
   #### 图解：
   ![insert](https://user-images.githubusercontent.com/49053144/202766114-5768d83f-e6c9-4dc7-8a5f-8505cff18829.gif)
  
   #### 描述：

      1、将数组分为两个区域，排序区域与未排序区域，每轮从未排序区域中取出第一个元素，插入可排序区域（需要保证顺序），重复以上步骤，直至有有序。
      2、插入时可以直接移动元素，而不是交换元素。
     
 ***插入与选择的比较***
 
      1、二者平均时间复杂度都是O(n^2)；
      2、大部分情况下，插入略优于选择；
      3、但如果集合**有序**度高，插入时间复杂度为O(n)；
      4、插入属于**稳定**排序算法，而选择**不稳定*的。
      
      
### 希尔（Sort.shell）
   #### 图解：
   ![shell](https://user-images.githubusercontent.com/49053144/202767062-82ea9aba-fa84-4092-9ebe-6093f832d9e7.gif)

   #### 思想：使用数组中任意间隔为h的元素都是有序的，这样的数组被称为h有序数组。
   
   
### 快速排序（Sort.quickLomuto/Sort.quickHoare）  

   #### 图解：
   ![quick](https://user-images.githubusercontent.com/49053144/202770408-666af380-28b1-41a7-a132-d6ff06e081ec.gif)
  
   #### 描述：

      1、每一轮排序选择一个基准点（pivot）进行分区
          a.让小于基准点的元素进入一个分区，大于基准点的元素进入另一个分区；
          b.当分区完成时，基准点元素的位置就是其最终位置。
      2、在子分区内重复以上过程，直至子分区元素个数少于等于1，这体现的是分而治之的思想（divide-and-conquer）。
      
   #### 实现方式：
      
      1、单边循环（Lomuto洛穆托分区方案）
          a.选择最右元素作为基准点；
          b.j指针负责找到比基准点小的元素，一旦找到则与i进行交换；
          c.i指针维护小于基准点元素的边界，也是每次交换时的目标索引；
          d.最后基准点与i交换，i即为分区位置。
      2、双边循环（并不完全等价于Hoare霍尔分区方案）
          a.选择最左元素作为基准点元素；
          b.j指针负责从右向左找比基准点小的元素，i指针负责从左向右找比基准点大的元素，一旦找到二者交换，直至i,j相交；
          c.最后基准点与i比时，i与j交换，i即为分区位置。


## 3、集合（basis/list）
### ArrayList
   #### 扩容机制
   * ArrayList()会使用长度为0的数组。
   * ArrayList(int initalCapacity)会使用指定容量的数组。
   * ArrayList(Collection<? extents E> c)会使用c的大小作为数组容量。
   * add(Object o) 首次扩容为10，再扩容为上次容量的1.5倍；上次扩容量 >> 1（相当于除后取整）。
   * addAll(Collection c)没有元素时，扩容为 Math.max(10,实际元素个数)，有元素为 Math.max(原容量1.5倍,实际元素个数)。
   
   #### 迭代器（Iterator)
   * fail-fast：一旦发现遍历的同时，其他人来修改，则立刻抛异常（）
   * fail-safe：发现遍历的同时，其他人来修改，应当能有应对策略，例如：牺牲一致性，来让整个遍历运行完成。
      ##### 总结：
         1）ArrayList是fail-fast的典型代表，遍历的同时不能修改，尽快失败。
         2）CopyOnWriteArrayList是fail-safe的典型代表，遍历的同时可以修改，原理是读写分离。
      ##### Vector实现是哪一种？

### LinkedList
#### ArrayList与LinkedList比较
   #### ArrayList
   * 基于数组，需要连续内存
   * 随机访问快（指根据下标访问）
   * 尾部插入、删除性能可以，其他部分插入、删除都会移动数据，因此性能会低
   * 可以利用cpu缓存，局部性原理
   #### LinkedList
   * 基于双向链表，无需连续内存
   * 随机访问慢（要沿着链表遍历）
   * 头尾插入、删除性能高
   * 占用内存多


